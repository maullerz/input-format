{"version":3,"file":"format.js","names":["template_formatter","format","value","caret","formatter","text","template","undefined","length","index","found","possibly_last_input_character_index"],"sources":["../source/format.js"],"sourcesContent":["import template_formatter from './templateFormatter.js'\n\n// Formats `value` value preserving `caret` at the same character.\n//\n// `{ value, caret }` attribute is the result of `parse()` function call.\n//\n// Returns `{ text, caret }` where the new `caret` is the caret position\n// inside `text` text corresponding to the original `caret` position inside `value`.\n//\n// `formatter(value)` is a function returning `{ text, template }`.\n//\n// `text` is the `value` value formatted using `template`.\n// It may either cut off the non-filled right part of the `template`\n// or it may fill the non-filled character placeholders\n// in the right part of the `template` with `spacer`\n// which is a space (' ') character by default.\n//\n// `template` is the template used to format the `value`.\n// It can be either a full-length template or a partial template.\n//\n// `formatter` can also be a string â€” a `template`\n// where character placeholders are denoted by 'x'es.\n// In this case `formatter` function is automatically created.\n//\n// Example:\n//\n// `value` is '880',\n// `caret` is `2` (before the first `0`)\n//\n// `formatter` is `'880' =>\n//   { text: '8 (80 )', template: 'x (xxx) xxx-xx-xx' }`\n//\n// The result is `{ text: '8 (80 )', caret: 4 }`.\n//\nexport default function format(value, caret, formatter)\n{\n\tif (typeof formatter === 'string')\n\t{\n\t\tformatter = template_formatter(formatter)\n\t}\n\n\tlet { text, template } = formatter(value) || {}\n\n\tif (text === undefined)\n\t{\n\t\t text = value\n\t}\n\n\tif (template)\n\t{\n\t\tif (caret === undefined)\n\t\t{\n\t\t\tcaret = text.length\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet index = 0\n\t\t\tlet found = false\n\n\t\t\tlet possibly_last_input_character_index = -1\n\n\t\t\twhile (index < text.length && index < template.length)\n\t\t\t{\n\t\t\t\t// Character placeholder found\n\t\t\t\tif (text[index] !== template[index])\n\t\t\t\t{\n\t\t\t\t\tif (caret === 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfound = true\n\t\t\t\t\t\tcaret = index\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t\tpossibly_last_input_character_index = index\n\n\t\t\t\t\tcaret--\n\t\t\t\t}\n\n\t\t\t\tindex++\n\t\t\t}\n\n\t\t\t// If the caret was positioned after last input character,\n\t\t\t// then the text caret index is just after the last input character.\n\t\t\tif (!found)\n\t\t\t{\n\t\t\t\tcaret = possibly_last_input_character_index + 1\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { text, caret }\n}"],"mappings":"AAAA,OAAOA,kBAAP,MAA+B,wBAA/B,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,MAAT,CAAgBC,KAAhB,EAAuBC,KAAvB,EAA8BC,SAA9B,EACf;EACC,IAAI,OAAOA,SAAP,KAAqB,QAAzB,EACA;IACCA,SAAS,GAAGJ,kBAAkB,CAACI,SAAD,CAA9B;EACA;;EAED,IAAI;IAAEC,IAAF;IAAQC;EAAR,IAAqBF,SAAS,CAACF,KAAD,CAAT,IAAoB,EAA7C;;EAEA,IAAIG,IAAI,KAAKE,SAAb,EACA;IACEF,IAAI,GAAGH,KAAP;EACD;;EAED,IAAII,QAAJ,EACA;IACC,IAAIH,KAAK,KAAKI,SAAd,EACA;MACCJ,KAAK,GAAGE,IAAI,CAACG,MAAb;IACA,CAHD,MAKA;MACC,IAAIC,KAAK,GAAG,CAAZ;MACA,IAAIC,KAAK,GAAG,KAAZ;MAEA,IAAIC,mCAAmC,GAAG,CAAC,CAA3C;;MAEA,OAAOF,KAAK,GAAGJ,IAAI,CAACG,MAAb,IAAuBC,KAAK,GAAGH,QAAQ,CAACE,MAA/C,EACA;QACC;QACA,IAAIH,IAAI,CAACI,KAAD,CAAJ,KAAgBH,QAAQ,CAACG,KAAD,CAA5B,EACA;UACC,IAAIN,KAAK,KAAK,CAAd,EACA;YACCO,KAAK,GAAG,IAAR;YACAP,KAAK,GAAGM,KAAR;YACA;UACA;;UAEDE,mCAAmC,GAAGF,KAAtC;UAEAN,KAAK;QACL;;QAEDM,KAAK;MACL,CAxBF,CA0BC;MACA;;;MACA,IAAI,CAACC,KAAL,EACA;QACCP,KAAK,GAAGQ,mCAAmC,GAAG,CAA9C;MACA;IACD;EACD;;EAED,OAAO;IAAEN,IAAF;IAAQF;EAAR,CAAP;AACA"}