{"version":3,"file":"templateFormatter.js","names":["template","placeholder","should_close_braces","value","text","characters_in_template","count_occurences","value_character_index","filled_in_template","split","character","length","close_braces"],"sources":["../source/templateFormatter.js"],"sourcesContent":["import { count_occurences } from './helpers.js'\nimport close_braces from './closeBraces.js'\n\n// Takes a `template` where character placeholders\n// are denoted by 'x'es (e.g. 'x (xxx) xxx-xx-xx').\n//\n// Returns a function which takes `value` characters\n// and returns the `template` filled with those characters.\n// If the `template` can only be partially filled\n// then it is cut off.\n//\n// If `should_close_braces` is `true`,\n// then it will also make sure all dangling braces are closed,\n// e.g. \"8 (8\" -> \"8 (8  )\" (iPhone style phone number input).\n//\nexport default function(template, placeholder = 'x', should_close_braces)\n{\n\tif (!template)\n\t{\n\t\treturn value => ({ text: value })\n\t}\n\n\tconst characters_in_template = count_occurences(placeholder, template)\n\n\treturn function(value)\n\t{\n\t\tif (!value)\n\t\t{\n\t\t\treturn { text: '', template }\n\t\t}\n\n\t\tlet value_character_index = 0\n\t\tlet filled_in_template = ''\n\n\t\t// Using `.split('')` here instead of normal `for ... of`\n\t\t// because the importing application doesn't neccessarily include an ES6 polyfill.\n\t\t// The `.split('')` approach discards \"exotic\" UTF-8 characters\n\t\t// (the ones consisting of four bytes)\n\t\t// but template placeholder characters don't fall into that range\n\t\t// and appending UTF-8 characters to a string in parts still works.\n\t\tfor (const character of template.split(''))\n\t\t{\n\t\t\tif (character !== placeholder)\n\t\t\t{\n\t\t\t\tfilled_in_template += character\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfilled_in_template += value[value_character_index]\n\t\t\tvalue_character_index++\n\n\t\t\t// If the last available value character has been filled in,\n\t\t\t// then return the filled in template\n\t\t\t// (either trim the right part or retain it,\n\t\t\t//  if no more character placeholders in there)\n\t\t\tif (value_character_index === value.length)\n\t\t\t{\n\t\t\t\t// If there are more character placeholders\n\t\t\t\t// in the right part of the template\n\t\t\t\t// then simply trim it.\n\t\t\t\tif (value.length < characters_in_template)\n\t\t\t\t{\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (should_close_braces)\n\t\t{\n\t\t\tfilled_in_template = close_braces(filled_in_template, template)\n\t\t}\n\n\t\treturn { text: filled_in_template, template }\n\t}\n}"],"mappings":";;;;;;;AAAA;;AACA;;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,kBAASA,QAAT,EACf;EAAA,IADkCC,WAClC,uEADgD,GAChD;EAAA,IADqDC,mBACrD;;EACC,IAAI,CAACF,QAAL,EACA;IACC,OAAOG,KAAK,KAAK;MAAEC,IAAI,EAAED;IAAR,CAAL,CAAZ;EACA;;EAED,MAAME,sBAAsB,GAAG,IAAAC,yBAAA,EAAiBL,WAAjB,EAA8BD,QAA9B,CAA/B;EAEA,OAAO,UAASG,KAAT,EACP;IACC,IAAI,CAACA,KAAL,EACA;MACC,OAAO;QAAEC,IAAI,EAAE,EAAR;QAAYJ;MAAZ,CAAP;IACA;;IAED,IAAIO,qBAAqB,GAAG,CAA5B;IACA,IAAIC,kBAAkB,GAAG,EAAzB,CAPD,CASC;IACA;IACA;IACA;IACA;IACA;;IACA,qDAAwBR,QAAQ,CAACS,KAAT,CAAe,EAAf,CAAxB,wCACA;MAAA,MADWC,SACX;;MACC,IAAIA,SAAS,KAAKT,WAAlB,EACA;QACCO,kBAAkB,IAAIE,SAAtB;QACA;MACA;;MAEDF,kBAAkB,IAAIL,KAAK,CAACI,qBAAD,CAA3B;MACAA,qBAAqB,GARtB,CAUC;MACA;MACA;MACA;;MACA,IAAIA,qBAAqB,KAAKJ,KAAK,CAACQ,MAApC,EACA;QACC;QACA;QACA;QACA,IAAIR,KAAK,CAACQ,MAAN,GAAeN,sBAAnB,EACA;UACC;QACA;MACD;IACD;;IAED,IAAIH,mBAAJ,EACA;MACCM,kBAAkB,GAAG,IAAAI,oBAAA,EAAaJ,kBAAb,EAAiCR,QAAjC,CAArB;IACA;;IAED,OAAO;MAAEI,IAAI,EAAEI,kBAAR;MAA4BR;IAA5B,CAAP;EACA,CAjDD;AAkDA"}